# FUSE using Memcached
ჩვენი ძირითადი ამოცანაა ფაილური სისტემა წარმოვადგინოთ key-value სახით, გვაქვს დირექტორიები და ფაილები, რომელთა ზომაც შეიძლება საკმაოდ დიდი იყოს, ხოლო memcached-ის მუშაობის პრინციპიდან გამომდინარე key-ს შეკითხვისას მთლიანი value იგზავნება ქსელში(ამის გარდა value-ს ზომა ისედაც შეზღუდულია მემქეშდის მიერ).
## ძირითადი მექანიზმი:
გვაქვს ორი ძირითადი ფაილი: ერთი, რომელიც მემქეშდთან მარტივად ურთიერთობის საშუალებას გვაძლევს და მეორე, რომელიც პირველის გამოყენებით ამუშავებს FUSE-ს სისტემქოლებს.
### MEMCACHED-ის მხარე
გვაქვს memcached.h-ში აღწერილი მეთოდები რომელსაც FUSE იყენებს, ასევე სტრუქტურა, რომელიც ორივე მხარისთვის ცნობილია.
ნებისმიერი value-ს პირველი წევრია სტრუქტურა, რომელიც წარმოადგენს ერთ ინტს(მთლიანი value-ს ზომა ბაიტებში ამავე სტრუქტურის ჩათვლით). (რატომ სტრუქტურა და არა უბრალოდ ინტი? იმიტომ რომ შემდეგ შეცვლა, რამის დამატება ძალიან მარტივი იქნება).
```
struct bucket_struct {
	int cur_size;

};
```
memcached.h -ში დატოვებულია პარამეტრების სამართავი რიცხვები:
#define SPACE_FOR_STRUCTS 200 სტრუქტურებისთვის საჭირო მეხსიერება კალათებში.
#define MAX_BUCKET_SIZE 1024 ფაილებისთვის თითოეულ კალათაში data-ს ზომა.
#define FAST_MODE 0 (default 0) ფაილში ჩაწერის ტესტი ბევრად სწრაფია 1ის შემთხვევაში, რადგანაც STORED მესიჯებს არ ველოდებით, რამაც შეიძლება პრობლემები გამოიწვიოს

### FUSE-ის მხარე
გადატვირთულია ამ პროექტისთვის საჭირო FUSE-ის მეთოდები
## დირექტორიებისა და ფაილების აგებულება
ნებისმიერი დირექტორიისა თუ ფაილისთვის გვაქვს მთავარი და ქვემდებარე key-value-ები,
კერძოდ: მთავარ ნაწილის key-ს წარმოადგენს full-path კონკრეტული ფაილისა თუ დირექტორიისა, ხოლო value ზოგად ინფორმაციას ამ ფაილსა თუ დირექტორიაზე, რომელიც ცალკე სტრუქტურაა(არ დაგვავიწყდეს ამ სტრუქტურამდე ზემოთ, მემქეშდში აღწერილი სტრუქტურა გვაქვს), ამ სტრუქტურის პირველ ელემეტნს წარმოადგენს isDir, რომელიც 1 არის დირექტორიის შემთხვევაში, ხოლო 0 ფაილებისთვის.
ეს სტრუქტურა შემდგომში დამატებითი ატრიბუტებისთვისაც გამოვიყენე და is_dir 2ია მაგ შემთხვევაში.
```
struct header_struct {
	int is_dir; // 0 = file, 1 = dir, 2 = xattr
	int data_len; // length of real data	
	int num_buckets; // number of child buckets
	int parent_index; // index for the current file/directory in parent directories children.
	int xattr_num; //number of extended attributes
	
};
```
ორივე შემთხვევაში გვაქვს num_buckets-რომლითაც ვინახავთ დანარჩენი კალათების რაოდენობას ამ კონკრეტული ფაილისა თუ დირექტორიისთვის, კონკრეტული ბაქეთის მიღებისთვის კი key-ს თავში ვაწებებთ ნომერს(1-დან დაწყებულს), დირექტორიებისთვის თითოელ დამხმარე ბაქეთში ინახება თითო შვილის full-path, ხოლო ფაილებისთვის data.
ფაილების შემთხვევაში თუ ფაილის დატაა შვილეულ ბაქეთში, მაშინ შედგენილ key-ს წინ ვუმატებთ სიმბოლო &-ს, ხოლო თუ დამატებითი ატრიბუტია სიმბოლო $-ს, მათი რაოდენობები კი ცალ-ცალკე ითვლება.
parent_index არის მშობელი დირექტორიის რომელ კალათაში ვინახავთ ამ კონკრეტული დირექტორიისა თუ ფაილის full-path-ს, ეს გვჭირდება წაშლის მექანიზმისთვის, რომლის ზოგადი ალგორითმი ასეთია: ამ დირექტორიის ბოლო ელემენტს  და გადავსვამთ წასაშლელი ელემენტის ადგილას, ანუ key იგივეს ვუტოვებთ რაც წასაშლელს ჰქონდა, ხოლო value-ბოლო ელემენტის გადმოგვაქვს(რომელიც უბრალოდ full-path-ია (რა თქმა უნდა სტრუქტურით)), შემდეგ კი ბოლო ელემენტს ვშლით, გადმოტანილი ფაილის/dir-ის parent_index-საც ვანახლებთ. ასეთივეა ატრიბუტების წასაშლელი მექანიზმიც.
ატრიბუტების value: თავიდან, ისევე როგორც ყველგან, გვაქვს bucket_Struct, შემდეგ მოსდევს ეგრევე header_struct, შემდეგ int, რომელშიც წერია ამ ატრიბუტის სახელის სიგრძე, შემდეგ სახელი, შემდეგ int, რომელშიც value-ს სიგრძე წერია ბაიტებში და შემდეგ მოსდევს value.
უნდა აღინიშნოს რომ გვაქვს ცალკეული key:value; key = "stats", სადაც ვინახავთ ზოგად ინფორმაციას ფაილური სისტემის შესახებ.
```
struct stats_struct {
	int total_bytes; //ბაიტების მთლიანი რაოდენობა
	int block_size; // ფაილების ბლოკის ზომა(ეს გვჭირდება საწყისი შემოწმებისთვის)

};
```
პროექტის შესრულებული ნაწილები: 1, 2, 3, 4, 5, 8
კომპილირდება როგორც მოთხოვნაში იყო...
